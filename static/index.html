<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Network Connectivity Monitor</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, sans-serif;
        background: #f5f5f5;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      h1 {
        color: #333;
        margin-bottom: 20px;
      }

      .dashboard {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .card {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .card h2 {
        font-size: 18px;
        color: #666;
        margin-bottom: 15px;
      }

      .stat-value {
        font-size: 36px;
        font-weight: bold;
        color: #333;
      }

      .stat-label {
        font-size: 14px;
        color: #999;
        margin-top: 5px;
      }

      .status-good {
        color: #22c55e;
      }
      .status-warning {
        color: #f59e0b;
      }
      .status-bad {
        color: #ef4444;
      }

      .chart-container {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }

      .chart-container h2 {
        font-size: 20px;
        color: #333;
        margin-bottom: 20px;
      }

      #latency-chart,
      #availability-chart {
        width: 100%;
        height: 300px;
      }

      .outages-table {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      th,
      td {
        text-align: left;
        padding: 12px;
        border-bottom: 1px solid #eee;
      }

      th {
        background: #f9f9f9;
        font-weight: 600;
        color: #666;
      }

      .controls {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        align-items: center;
      }

      select,
      button {
        padding: 8px 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        font-size: 14px;
      }

      button {
        background: #3b82f6;
        color: white;
        cursor: pointer;
        border: none;
      }

      button:hover {
        background: #2563eb;
      }

      .tooltip {
        position: absolute;
        padding: 8px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
      }

      .axis {
        font-size: 12px;
      }

      .grid line {
        stroke: #e5e5e5;
        stroke-opacity: 0.7;
        shape-rendering: crispEdges;
      }

      .grid path {
        stroke-width: 0;
      }

      .line {
        fill: none;
        stroke-width: 2;
      }

      .dot {
        stroke-width: 2;
        stroke: white;
      }

      .legend {
        font-size: 12px;
      }

      .heatmap-cell {
        stroke: white;
        stroke-width: 1;
        cursor: pointer;
      }

      .heatmap-label {
        font-size: 11px;
        fill: #666;
      }

      .heatmap-legend {
        font-size: 12px;
      }

      .pattern-details {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üåê Network Connectivity Monitor</h1>

      <div class="controls">
        <label>Time Range:</label>
        <select id="timeRange">
          <option value="1">Last Hour</option>
          <option value="6">Last 6 Hours</option>
          <option value="24" selected>Last 24 Hours</option>
          <option value="72">Last 3 Days</option>
          <option value="168">Last Week</option>
        </select>
        <button onclick="refreshData()">Refresh</button>
        <button onclick="generateReport()">Generate Report</button>
        <label style="margin-left: 20px">Heatmap Days:</label>
        <select id="heatmapDays">
          <option value="7">Last 7 Days</option>
          <option value="14">Last 14 Days</option>
          <option value="30" selected>Last 30 Days</option>
          <option value="60">Last 60 Days</option>
          <option value="90">Last 90 Days</option>
        </select>
      </div>

      <div class="dashboard" id="statsCards"></div>

      <div class="chart-container">
        <h2>Latency Over Time</h2>
        <svg id="latency-chart"></svg>
      </div>

      <div class="chart-container">
        <h2>Availability Timeline</h2>
        <svg id="availability-chart"></svg>
      </div>

      <div class="chart-container">
        <h2>Issue Pattern Heatmap - 24 Hour Overlay</h2>
        <div
          id="heatmap-info"
          style="margin-bottom: 10px; font-size: 14px; color: #666"
        >
          Shows failure rate and latency patterns across a 24-hour period,
          aggregated over selected time range
        </div>
        <svg id="heatmap-chart"></svg>
      </div>

      <div class="outages-table">
        <h2>Recent Outages</h2>
        <table id="outagesTable">
          <thead>
            <tr>
              <th>Target</th>
              <th>Start Time</th>
              <th>Duration</th>
              <th>Failed Checks</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="tooltip" style="opacity: 0"></div>

    <script>
      let currentData = [];
      let stats = [];
      let outages = [];
      let heatmapData = [];

      const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
      const tooltip = d3.select(".tooltip");

      async function fetchData(hours = 24) {
        try {
          const heatmapDays = document.getElementById("heatmapDays").value;
          const [recentRes, statsRes, outagesRes, heatmapRes] =
            await Promise.all([
              fetch(`/api/recent?hours=${hours}`),
              fetch("/api/stats"),
              fetch("/api/outages"),
              fetch(`/api/heatmap?days=${heatmapDays}`),
            ]);

          currentData = await recentRes.json();
          stats = await statsRes.json();
          outages = await outagesRes.json();
          heatmapData = await heatmapRes.json();

          updateDashboard();
          drawLatencyChart();
          drawAvailabilityChart();
          drawHeatmap();
          updateOutagesTable();
        } catch (error) {
          console.error("Error fetching data:", error);
        }
      }

      function updateDashboard() {
        const container = document.getElementById("statsCards");
        container.innerHTML = "";

        stats.forEach((stat) => {
          const card = document.createElement("div");
          card.className = "card";

          const uptime = (
            (stat.successful_pings / stat.total_pings) *
            100
          ).toFixed(2);
          const statusClass =
            uptime >= 99
              ? "status-good"
              : uptime >= 95
              ? "status-warning"
              : "status-bad";

          card.innerHTML = `
                    <h2>${stat.target}</h2>
                    <div class="stat-value ${statusClass}">${uptime}%</div>
                    <div class="stat-label">Uptime (${
                      stat.total_pings
                    } pings)</div>
                    <div style="margin-top: 15px; font-size: 14px; color: #666;">
                        <div>Avg RTT: ${
                          stat.avg_rtt?.toFixed(1) || "N/A"
                        } ms</div>
                        <div>Min/Max: ${stat.min_rtt?.toFixed(1) || "N/A"}/${
            stat.max_rtt?.toFixed(1) || "N/A"
          } ms</div>
                        <div>Packet Loss: ${stat.packet_loss.toFixed(1)}%</div>
                    </div>
                `;
          container.appendChild(card);
        });
      }

      function drawLatencyChart() {
        const container = d3.select("#latency-chart");
        container.selectAll("*").remove();

        const margin = { top: 20, right: 120, bottom: 40, left: 60 };
        const width =
          container.node().getBoundingClientRect().width -
          margin.left -
          margin.right;
        const height = 300 - margin.top - margin.bottom;

        const svg = container
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);

        const g = svg
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Parse and group data
        const parseTime = d3.timeParse("%Y-%m-%dT%H:%M:%S");
        currentData.forEach((d) => {
          if (d.timestamp) {
            d.date = parseTime(d.timestamp.split(".")[0]);
          }
        });

        const targets = [...new Set(currentData.map((d) => d.target))];
        const dataByTarget = targets.map((target) => {
          return {
            target: target,
            values: currentData
              .filter((d) => d.target === target && d.success)
              .map((d) => ({ date: d.date, value: d.rtt_ms }))
              .sort((a, b) => a.date - b.date),
          };
        });

        // Scales
        const x = d3
          .scaleTime()
          .domain(d3.extent(currentData, (d) => d.date))
          .range([0, width]);

        const y = d3
          .scaleLinear()
          .domain([
            0,
            d3.max(
              currentData.filter((d) => d.success),
              (d) => d.rtt_ms
            ),
          ])
          .nice()
          .range([height, 0]);

        // Grid
        g.append("g")
          .attr("class", "grid")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(x).tickSize(-height).tickFormat(""));

        g.append("g")
          .attr("class", "grid")
          .call(d3.axisLeft(y).tickSize(-width).tickFormat(""));

        // Axes
        g.append("g")
          .attr("transform", `translate(0,${height})`)
          .attr("class", "axis")
          .call(d3.axisBottom(x).tickFormat(d3.timeFormat("%H:%M")));

        g.append("g").attr("class", "axis").call(d3.axisLeft(y));

        // Y-axis label
        g.append("text")
          .attr("transform", "rotate(-90)")
          .attr("y", 0 - margin.left)
          .attr("x", 0 - height / 2)
          .attr("dy", "1em")
          .style("text-anchor", "middle")
          .style("font-size", "12px")
          .text("Latency (ms)");

        // Line generator
        const line = d3
          .line()
          .x((d) => x(d.date))
          .y((d) => y(d.value))
          .curve(d3.curveMonotoneX);

        // Draw lines
        const lines = g
          .selectAll(".line-group")
          .data(dataByTarget)
          .enter()
          .append("g")
          .attr("class", "line-group");

        lines
          .append("path")
          .attr("class", "line")
          .attr("d", (d) => line(d.values))
          .style("stroke", (d) => colorScale(d.target));

        // Add dots
        lines
          .selectAll(".dot")
          .data((d) => d.values.map((v) => ({ ...v, target: d.target })))
          .enter()
          .append("circle")
          .attr("class", "dot")
          .attr("cx", (d) => x(d.date))
          .attr("cy", (d) => y(d.value))
          .attr("r", 3)
          .style("fill", (d) => colorScale(d.target))
          .on("mouseover", function (event, d) {
            tooltip
              .style("opacity", 1)
              .html(
                `${d.target}<br/>RTT: ${d.value.toFixed(
                  1
                )} ms<br/>${d3.timeFormat("%H:%M:%S")(d.date)}`
              );
          })
          .on("mousemove", function (event) {
            tooltip
              .style("left", event.pageX + 10 + "px")
              .style("top", event.pageY - 28 + "px");
          })
          .on("mouseout", function () {
            tooltip.style("opacity", 0);
          });

        // Legend
        const legend = svg
          .append("g")
          .attr("class", "legend")
          .attr(
            "transform",
            `translate(${width + margin.left + 10}, ${margin.top})`
          );

        targets.forEach((target, i) => {
          const legendRow = legend
            .append("g")
            .attr("transform", `translate(0, ${i * 20})`);

          legendRow
            .append("rect")
            .attr("width", 10)
            .attr("height", 10)
            .attr("fill", colorScale(target));

          legendRow
            .append("text")
            .attr("x", 15)
            .attr("y", 10)
            .style("font-size", "12px")
            .text(target);
        });
      }

      function drawAvailabilityChart() {
        const container = d3.select("#availability-chart");
        container.selectAll("*").remove();

        const margin = { top: 20, right: 120, bottom: 40, left: 60 };
        const width =
          container.node().getBoundingClientRect().width -
          margin.left -
          margin.right;
        const height = 300 - margin.top - margin.bottom;

        const svg = container
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);

        const g = svg
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const targets = [...new Set(currentData.map((d) => d.target))];
        const targetHeight = height / targets.length;

        // Time scale
        const parseTime = d3.timeParse("%Y-%m-%dT%H:%M:%S");
        currentData.forEach((d) => {
          if (d.timestamp) {
            d.date = parseTime(d.timestamp.split(".")[0]);
          }
        });

        const x = d3
          .scaleTime()
          .domain(d3.extent(currentData, (d) => d.date))
          .range([0, width]);

        // Draw availability bars for each target
        targets.forEach((target, i) => {
          const targetData = currentData
            .filter((d) => d.target === target)
            .sort((a, b) => a.date - b.date);

          const y = i * targetHeight + 10;

          // Background
          g.append("rect")
            .attr("x", 0)
            .attr("y", y)
            .attr("width", width)
            .attr("height", targetHeight - 20)
            .attr("fill", "#f3f3f3");

          // Availability blocks
          g.selectAll(`.availability-${i}`)
            .data(targetData)
            .enter()
            .append("rect")
            .attr("class", `availability-${i}`)
            .attr("x", (d) => x(d.date))
            .attr("y", y)
            .attr("width", 2)
            .attr("height", targetHeight - 20)
            .attr("fill", (d) => (d.success ? "#22c55e" : "#ef4444"))
            .on("mouseover", function (event, d) {
              tooltip
                .style("opacity", 1)
                .html(
                  `${target}<br/>${
                    d.success ? "Online" : "Offline"
                  }<br/>${d3.timeFormat("%H:%M:%S")(d.date)}`
                );
            })
            .on("mousemove", function (event) {
              tooltip
                .style("left", event.pageX + 10 + "px")
                .style("top", event.pageY - 28 + "px");
            })
            .on("mouseout", function () {
              tooltip.style("opacity", 0);
            });

          // Target label
          g.append("text")
            .attr("x", -margin.left + 5)
            .attr("y", y + targetHeight / 2 - 10)
            .style("font-size", "12px")
            .style("dominant-baseline", "middle")
            .text(target);
        });

        // X-axis
        g.append("g")
          .attr("transform", `translate(0,${height})`)
          .attr("class", "axis")
          .call(d3.axisBottom(x).tickFormat(d3.timeFormat("%H:%M")));

        // Legend
        const legend = svg
          .append("g")
          .attr(
            "transform",
            `translate(${width + margin.left + 10}, ${margin.top})`
          );

        const legendData = [
          { label: "Online", color: "#22c55e" },
          { label: "Offline", color: "#ef4444" },
        ];

        legendData.forEach((item, i) => {
          const legendRow = legend
            .append("g")
            .attr("transform", `translate(0, ${i * 20})`);

          legendRow
            .append("rect")
            .attr("width", 10)
            .attr("height", 10)
            .attr("fill", item.color);

          legendRow
            .append("text")
            .attr("x", 15)
            .attr("y", 10)
            .style("font-size", "12px")
            .text(item.label);
        });
      }

      function drawHeatmap() {
        const container = d3.select("#heatmap-chart");
        container.selectAll("*").remove();

        if (!heatmapData || heatmapData.length === 0) {
          container
            .append("text")
            .attr("x", 20)
            .attr("y", 30)
            .text(
              "Insufficient data for heatmap. Data will appear after an hour of monitoring."
            );
          return;
        }

        const margin = { top: 50, right: 150, bottom: 50, left: 100 };
        const width =
          container.node().getBoundingClientRect().width -
          margin.left -
          margin.right;
        const cellSize = Math.floor(width / 24);
        const targets = [...new Set(heatmapData.map((d) => d.target))];
        const height = cellSize * targets.length;

        const svg = container
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);

        const g = svg
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Create scales
        const xScale = d3
          .scaleBand()
          .domain(d3.range(24))
          .range([0, width])
          .padding(0.05);

        const yScale = d3
          .scaleBand()
          .domain(targets)
          .range([0, height])
          .padding(0.05);

        // Color scale for failure rate
        const colorScale = d3
          .scaleSequential()
          .domain([0, 20]) // 0-20% failure rate
          .interpolator(d3.interpolateRgb("#10b981", "#ef4444"))
          .clamp(true);

        // Alternative: Color scale for latency
        const latencyColorScale = d3
          .scaleSequential()
          .domain([0, 100]) // 0-100ms latency
          .interpolator(d3.interpolateRgb("#3b82f6", "#f59e0b"))
          .clamp(true);

        // Draw cells
        const cells = g
          .selectAll(".heatmap-cell")
          .data(heatmapData)
          .enter()
          .append("rect")
          .attr("class", "heatmap-cell")
          .attr("x", (d) => xScale(d.hour))
          .attr("y", (d) => yScale(d.target))
          .attr("width", xScale.bandwidth())
          .attr("height", yScale.bandwidth())
          .attr("fill", (d) => {
            // Use failure rate as primary indicator
            if (d.failure_rate > 0) {
              return colorScale(d.failure_rate);
            }
            // If no failures, show latency
            return d.avg_latency > 50
              ? latencyColorScale(d.avg_latency)
              : "#10b981";
          })
          .attr("opacity", (d) => {
            // Make opacity based on data density
            return Math.min(1, 0.3 + (d.days_with_data / 30) * 0.7);
          })
          .on("mouseover", function (event, d) {
            const days = document.getElementById("heatmapDays").value;
            tooltip.style("opacity", 1).html(`
                            <strong>${d.target} - ${d.hour}:00</strong><br/>
                            Failure Rate: ${d.failure_rate.toFixed(1)}%<br/>
                            Avg Latency: ${d.avg_latency.toFixed(1)} ms<br/>
                            Max Latency: ${d.max_latency.toFixed(1)} ms<br/>
                            Failed/Total: ${
                              d.total_failures
                            }/${d.total_pings}<br/>
                            Days with data: ${d.days_with_data}/${days}
                        `);
          })
          .on("mousemove", function (event) {
            tooltip
              .style("left", event.pageX + 10 + "px")
              .style("top", event.pageY - 28 + "px");
          })
          .on("mouseout", function () {
            tooltip.style("opacity", 0);
          })
          .on("click", function (event, d) {
            showPatternDetails(d.hour);
          });

        // Add text labels for significant issues
        g.selectAll(".issue-label")
          .data(heatmapData.filter((d) => d.failure_rate > 10))
          .enter()
          .append("text")
          .attr("class", "issue-label")
          .attr("x", (d) => xScale(d.hour) + xScale.bandwidth() / 2)
          .attr("y", (d) => yScale(d.target) + yScale.bandwidth() / 2)
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .style("fill", "white")
          .style("font-size", "10px")
          .style("font-weight", "bold")
          .style("pointer-events", "none")
          .text((d) => Math.round(d.failure_rate) + "%");

        // X-axis (hours)
        g.append("g")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(xScale).tickFormat((d) => d + ":00"))
          .selectAll("text")
          .attr("class", "heatmap-label")
          .style("text-anchor", "end")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .attr("transform", "rotate(-45)");

        // Y-axis (targets)
        g.append("g")
          .call(d3.axisLeft(yScale))
          .selectAll("text")
          .attr("class", "heatmap-label");

        // Title
        g.append("text")
          .attr("x", width / 2)
          .attr("y", -margin.top / 2)
          .attr("text-anchor", "middle")
          .style("font-size", "14px")
          .style("font-weight", "bold")
          .text("Connectivity Issues by Hour of Day");

        // Color legend
        const legendWidth = 100;
        const legendHeight = 20;

        const legendScale = d3
          .scaleLinear()
          .domain([0, 20])
          .range([0, legendWidth]);

        const legendAxis = d3
          .axisBottom(legendScale)
          .ticks(5)
          .tickFormat((d) => d + "%");

        const legend = svg
          .append("g")
          .attr("class", "heatmap-legend")
          .attr(
            "transform",
            `translate(${width + margin.left + 20}, ${margin.top})`
          );

        // Gradient definition
        const defs = svg.append("defs");
        const gradient = defs
          .append("linearGradient")
          .attr("id", "heatmap-gradient")
          .attr("x1", "0%")
          .attr("x2", "100%")
          .attr("y1", "0%")
          .attr("y2", "0%");

        const stops = d3.range(0, 1.1, 0.1);
        stops.forEach((stop) => {
          gradient
            .append("stop")
            .attr("offset", stop * 100 + "%")
            .attr("stop-color", colorScale(stop * 20));
        });

        legend
          .append("rect")
          .attr("width", legendWidth)
          .attr("height", legendHeight)
          .style("fill", "url(#heatmap-gradient)");

        legend
          .append("g")
          .attr("transform", `translate(0,${legendHeight})`)
          .call(legendAxis);

        legend
          .append("text")
          .attr("x", legendWidth / 2)
          .attr("y", -5)
          .attr("text-anchor", "middle")
          .style("font-size", "12px")
          .text("Failure Rate");

        // Add note about clicking for details
        svg
          .append("text")
          .attr("x", margin.left)
          .attr("y", height + margin.top + margin.bottom - 5)
          .style("font-size", "11px")
          .style("fill", "#999")
          .text("Click any cell to see detailed daily breakdown for that hour");
      }

      async function showPatternDetails(hour) {
        try {
          const response = await fetch(`/api/patterns?hour=${hour}`);
          const patterns = await response.json();

          if (!patterns || patterns.length === 0) return;

          // Create or update details panel
          let detailsDiv = document.getElementById("pattern-details");
          if (!detailsDiv) {
            detailsDiv = document.createElement("div");
            detailsDiv.id = "pattern-details";
            detailsDiv.className = "pattern-details";
            document.querySelector(".container").appendChild(detailsDiv);
          }

          // Group by target
          const byTarget = {};
          patterns.forEach((p) => {
            if (!byTarget[p.target]) byTarget[p.target] = [];
            byTarget[p.target].push(p);
          });

          let html = `<h3>Details for ${hour}:00</h3>`;

          Object.keys(byTarget).forEach((target) => {
            const targetPatterns = byTarget[target];
            const avgFailure =
              targetPatterns.reduce((sum, p) => sum + p.failure_rate, 0) /
              targetPatterns.length;

            html += `<h4>${target} (Avg failure: ${avgFailure.toFixed(
              1
            )}%)</h4>`;
            html += '<table style="width: 100%; font-size: 12px;">';
            html +=
              "<tr><th>Date</th><th>Failure Rate</th><th>Avg RTT</th><th>Max RTT</th></tr>";

            targetPatterns.slice(0, 10).forEach((p) => {
              const rowClass =
                p.failure_rate > 10
                  ? 'style="background: #fee;"'
                  : p.failure_rate > 5
                  ? 'style="background: #ffc;"'
                  : "";
              html += `<tr ${rowClass}>
                            <td>${p.date}</td>
                            <td>${p.failure_rate.toFixed(1)}%</td>
                            <td>${p.avg_rtt.toFixed(1)} ms</td>
                            <td>${p.max_rtt.toFixed(1)} ms</td>
                        </tr>`;
            });

            if (targetPatterns.length > 10) {
              html += `<tr><td colspan="4" style="text-align: center; color: #999;">
                                ... and ${
                                  targetPatterns.length - 10
                                } more days</td></tr>`;
            }

            html += "</table>";
          });

          html +=
            '<button onclick="document.getElementById(\'pattern-details\').remove()" style="margin-top: 10px;">Close</button>';

          detailsDiv.innerHTML = html;
          detailsDiv.scrollIntoView({ behavior: "smooth" });
        } catch (error) {
          console.error("Error fetching pattern details:", error);
        }
      }

      function updateOutagesTable() {
        const tbody = document.querySelector("#outagesTable tbody");
        tbody.innerHTML = "";

        if (!outages || outages.length === 0) {
          tbody.innerHTML =
            '<tr><td colspan="4" style="text-align: center; color: #999;">No outages detected</td></tr>';
          return;
        }

        outages.slice(0, 20).forEach((outage) => {
          const row = tbody.insertRow();
          const startTime = new Date(outage.start_time);
          const duration = parseDuration(outage.duration);

          row.innerHTML = `
                    <td>${outage.target}</td>
                    <td>${startTime.toLocaleString()}</td>
                    <td>${duration}</td>
                    <td>${outage.failed_checks}</td>
                `;
        });
      }

      function parseDuration(duration) {
        // Parse Go duration string
        const match = duration.match(/(\d+h)?(\d+m)?(\d+\.?\d*s)?/);
        if (!match) return duration;

        let result = "";
        if (match[1]) result += match[1] + " ";
        if (match[2]) result += match[2] + " ";
        if (match[3]) result += parseFloat(match[3]).toFixed(0) + "s";
        return result.trim();
      }

      function refreshData() {
        const hours = document.getElementById("timeRange").value;
        fetchData(hours);
      }

      function generateReport() {
        // This would trigger server-side report generation
        window.open(
          `/api/report?hours=${document.getElementById("timeRange").value}`,
          "_blank"
        );
      }

      document
        .getElementById("timeRange")
        .addEventListener("change", refreshData);
      document
        .getElementById("heatmapDays")
        .addEventListener("change", refreshData);

      // Initial load
      fetchData();

      // Auto-refresh every 30 seconds
      setInterval(() => refreshData(), 30000);
    </script>
  </body>
</html>
